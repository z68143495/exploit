<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script type="text/javascript" src="three.js"></script>
  <style>
    #canvas3d {
      width: 800px;
      height: 450px;
      margin: 100px auto;
    }
  </style>
</head>
<body>
<div id="canvas3d"></div>
<script>
  var renderer;   //渲染器
  var scene;　　　//场景
  var camera;    //相机
  var light;　　  //光源
  var cube;      //物体
  var pivot5, pivot6;
  control = new function () {
    this.rotationSpeed = 0.005;
    this.scale = 1;

    this.rotationSpeed2 = 0.05;
  }
  // 生成3d渲染器,设置渲染器的宽高和背景色，（通常我们可以直接获取页面上画布的宽高，便于嵌入改动）
  renderer = new THREE.WebGLRenderer({antialias: true}); //生成渲染器对象（antialias属性：抗锯齿效果为设置有效）
  renderer.setClearColor(0x333333, 1.0);
  // renderer.setSize(window.innerWidth, window.innerHeight)
  renderer.setSize('800', '450');
  // 设置一个场景，也就是一个三维空间，用 [Scene] 类声明一个叫 [scene] 的对象。
  scene = new THREE.Scene();
  // 设置一个摄像机camera
  // 四个参数分别代表了摄像机的视角、宽高比、近和远两个视截面。
  //设置透视投影的相机,默认情况下相机的上方向为Y轴，右方向为X轴，沿着Z轴朝里（视野角：fov 纵横比：aspect 相机离视体积最近的距离：near 相机离视体积最远的距离：far）
  camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
  // position and point the camera to the center of the scene
  camera.position.x = 0;
  camera.position.y = 0;
  camera.position.z = 50;
  camera.lookAt(scene.position); //设置视野的中心坐标
  //设置light
  light = new THREE.DirectionalLight(0xff0000, 1.0, 0);  //设置平行光
  light.position.set(200, 200, 200);    //设置光源向量
  scene.add(light);  // 追加光源到场景
  // 设置物体 object
  // var cubeGeometry = new THREE.BoxGeometry(20, 10, 15, 2, 3, 1); //设置长宽高 以及对应长宽高的分段，在使用线模式({wireframe:true})进行渲染的时候可以看到效果
  // var cubeMaterial = new THREE.MeshNormalMaterial({wireframe: true});  //材质
  // cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  // var border = new THREE.EdgesHelper(cube, 0xffff00);  //添加边框
  // scene.add(cube);
  // scene.add(border);
  //立方体
  var cubeGeometry = new THREE.BoxGeometry(15, 15, 15, 1, 1, 1);
  var cubeMaterial = new THREE.MeshNormalMaterial();  //材质

  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  // var border = new THREE.EdgesHelper( cube,0xffff00 );  //添加边框
  scene.add(cube);
  // scene.add(border);

  // //圆柱体
  // var cylinderGeometry = new THREE.CylinderGeometry(8, 8,10,30,30);
  // var cylinderMaterial = new THREE.MeshNormalMaterial();
  // var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial);
  // cylinder.position.x = -10;
  // cylinder.position.y = -5;
  // cylinder.position.z = 25;
  // cylinder.castShadow = true;
  // scene.add(cylinder);
  //
  // //球体
  // var sphereGeometry = new THREE.SphereGeometry(7, 25, 25);
  // var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
  // var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  //
  // // position the sphere
  // sphere.position.x = 0;
  // sphere.position.y = 0;
  // sphere.position.z = 0;
  // sphere.castShadow = true;
  //
  // // add the sphere to the scene
  // scene.add(sphere);
  //
  // //圆环
  // var torusGeometry = new THREE.TorusGeometry(10,3,20,20);
  // var torusMaterial = new THREE.MeshBasicMaterial();
  // var tours = new THREE.Mesh(torusGeometry,torusMaterial);
  // tours.position.x = 10;
  // tours.position.y = -10;
  // tours.position.z = -40;
  // tours.castShadow = true;

  // scene.add(tours);
  // 进行渲染
  //将渲染器的元素添加到页面中
  document.getElementById('canvas3d').appendChild(renderer.domElement);
  renderer.render(scene, camera);

  /*
       鼠标移动控制模型旋转思想：
       当按下鼠标时及时当前鼠标的水平坐标clientX1，在鼠标移动的过程中不断触发onMouseMove事件，
       不停的记录鼠标的当前坐标clientX2，由当前坐标减去记录的上一个水平坐标，
       并且将当前的坐标付给上一个坐标clientX1，计算两个坐标的之间的差clientX2-clientX1，
       将得到的差值除以一个常量（这个常量可以根据自己的需要调整），得到旋转的角度
   */
  document.addEventListener( 'mousedown', onMouseDown, false );
  document.addEventListener( 'mouseup', onMouseup, false );
  var rotateStart;
  var mouseDown;
  var mouseX;
  var mouseY;
  var deltaX;
  var deltaY;
  var degX;
  var degY;
  rotateStart = new THREE.Vector2();
  function onMouseDown(event) {
    //  阻止本来的默认事件，比如浏览器的默认右键事件是弹出浏览器的选项
    event.preventDefault();
    mouseDown = true;
    mouseX = event.clientX;
    mouseY = event.clientY;
    //出发事件时的鼠标指针的水平坐标
    rotateStart.set(event.clientX, event.clientY);
    document.addEventListener('mousemove', onMouseMove2, false);
  }

  function onMouseup(event) {
    mouseDown = false;
    document.removeEventListener("mousemove", onMouseMove2);
  }

  function onMouseMove2(event) {
    if (!mouseDown) {
      return;
    }
    deltaX = event.clientX - mouseX;
    mouseX = event.clientX;
    deltaY = event.clientY - mouseY;
    mouseY = event.clientY;
    rotateScene(deltaX,deltaY);
  }

  //设置模型旋转速度，可以根据自己的需要调整
  function rotateScene(deltaX, deltaY) {
    degX = deltaX / 279; //deg 设置模型旋转的弧度
    degY = deltaY / 279; //deg 设置模型旋转的弧度
    cube.rotation.y += degX;
    cube.rotation.x += degY;
    render();
  }
  function render() {
    renderer.render(scene, camera);
  }

  // 添加动画，我们要针对每个几何体添加不同的动画，所以就需要为每个几何体添加一个name属性来指定，比如：
  // cube.name = 'cube';
  // cylinder.name = 'cylinder';
  // tours.name = 'tours';
  // function render() {
  //   scene.getObjectByName('cube').rotation.x += control.rotationSpeed;
  //   // scene.getObjectByName('cube').scale.set(control.scale, control.scale, control.scale);
  //   // scene.getObjectByName('cylinder').rotation.z += control.rotationSpeed2;
  //   // scene.getObjectByName('tours').rotation.z += 0.05;
  //   renderer.render(scene, camera);
  //   requestAnimationFrame(render);
  // }
  // render()
</script>
</body>
</html>