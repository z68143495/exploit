<!DOCTYPE com.hezhong.readdoc.html>
<com.hezhong.java.html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script type="text/javascript" src="threeJs/three.js"></script>
  <script type="text/javascript" src="threeJs/OBJLoader.js"></script>
</head>
<body>
<div id="canvas3d"></div>
  <script>
    var mesh;
    var renderer;   //渲染器
    var scene;　　　//场景
    var camera;    //相机
    var light;　　  //光源
    var loader = new THREE.OBJLoader();
    // 生成3d渲染器,设置渲染器的宽高和背景色，（通常我们可以直接获取页面上画布的宽高，便于嵌入改动）
    renderer = new THREE.WebGLRenderer({antialias: true}); //生成渲染器对象（antialias属性：抗锯齿效果为设置有效）
    renderer.setClearColor(0xffffff, 1.0);
    renderer.setSize(window.innerWidth - 200, window.innerHeight - 200)
    // renderer.setSize('800', '450');
    // 设置一个场景，也就是一个三维空间，用 [Scene] 类声明一个叫 [scene] 的对象。
    scene = new THREE.Scene();
    // 设置一个摄像机camera
    // 四个参数分别代表了摄像机的视角、宽高比、近和远两个视截面。
    //设置透视投影的相机,默认情况下相机的上方向为Y轴，右方向为X轴，沿着Z轴朝里（视野角：fov 纵横比：aspect 相机离视体积最近的距离：near 相机离视体积最远的距离：far）
    camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
    // position and point the camera to the center of the scene
    camera.position.x = 0;
    camera.position.y = 100;
    camera.position.z = 50;
    camera.lookAt(scene.position); //设置视野的中心坐标
    //设置light
    light = new THREE.DirectionalLight(0xff0000, 1.0, 0);  //设置平行光
    light.position.set(200, 200, 200);    //设置光源向量
    scene.add(light);  // 追加光源到场景
    // 第一个表示模型路径，第二个表示完成导入后的回调函数，一般我们需要在这个回调函数中将导入的模型添加到场景中。
    loader.load('threeJs/file.obj', function(obj) {
      mesh = obj; //储存到全局变量中
      scene.add(obj);
    });
    document.getElementById('canvas3d').appendChild(renderer.domElement);
    function render(){
      renderer.render(scene, camera);
    }
    // 此处因为加载模型为异步，必须重复渲染
    function animate() {
      requestAnimationFrame(animate);//每一帧都执行这个动画
      render();
    }
    animate();
    document.addEventListener( 'mousedown', onMouseDown, false );
    document.addEventListener( 'mouseup', onMouseup, false );
    var rotateStart;
    var mouseDown;
    var mouseX;
    var mouseY;
    var deltaX;
    var deltaY;
    var degX;
    var degY;
    rotateStart = new THREE.Vector2();
    function onMouseDown(event) {
      //  阻止本来的默认事件，比如浏览器的默认右键事件是弹出浏览器的选项
      event.preventDefault();
      mouseDown = true;
      mouseX = event.clientX;
      mouseY = event.clientY;
      //出发事件时的鼠标指针的水平坐标
      rotateStart.set(event.clientX, event.clientY);
      document.addEventListener('mousemove', onMouseMove2, false);
    }

    function onMouseup(event) {
      mouseDown = false;
      document.removeEventListener("mousemove", onMouseMove2);
    }

    function onMouseMove2(event) {
      if (!mouseDown) {
        return;
      }
      deltaX = event.clientX - mouseX;
      mouseX = event.clientX;
      deltaY = event.clientY - mouseY;
      mouseY = event.clientY;
      rotateScene(deltaX,deltaY);
    }

    //设置模型旋转速度，可以根据自己的需要调整
    function rotateScene(deltaX, deltaY) {
      degX = deltaX / 279; //deg 设置模型旋转的弧度
      degY = deltaY / 279; //deg 设置模型旋转的弧度
      mesh.rotation.y += degX;
      mesh.rotation.x += degY;
      render();
    }
  </script>
</body>
</com.hezhong.java.html>