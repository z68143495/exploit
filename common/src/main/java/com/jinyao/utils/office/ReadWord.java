//package com.jinyao.utils.office;
//
//import com.jinyao.utils.IdGen;
//import org.apache.commons.lang3.StringUtils;
//import org.apache.poi.hwpf.HWPFDocument;
//import org.apache.poi.hwpf.converter.PicturesManager;
//import org.apache.poi.hwpf.converter.WordToHtmlConverter;
//import org.apache.poi.hwpf.usermodel.PictureType;
//import org.apache.poi.xwpf.converter.core.FileImageExtractor;
//import org.apache.poi.xwpf.converter.core.FileURIResolver;
//import org.apache.poi.xwpf.converter.xhtml.XHTMLConverter;
//import org.apache.poi.xwpf.converter.xhtml.XHTMLOptions;
//import org.apache.poi.xwpf.extractor.XWPFWordExtractor;
//import org.apache.poi.xwpf.usermodel.XWPFDocument;
//import org.jsoup.Jsoup;
//import org.jsoup.nodes.Document;
//import org.jsoup.nodes.Element;
//import org.jsoup.select.Elements;
//
//import javax.xml.parsers.DocumentBuilderFactory;
//import javax.xml.parsers.ParserConfigurationException;
//import javax.xml.transform.OutputKeys;
//import javax.xml.transform.Transformer;
//import javax.xml.transform.TransformerException;
//import javax.xml.transform.TransformerFactory;
//import javax.xml.transform.dom.DOMSource;
//import javax.xml.transform.stream.StreamResult;
//import java.io.*;
//import java.util.Iterator;
//import java.util.LinkedHashMap;
//import java.util.Map;
//
///***********************************************************************
// * 文件说明：
// * 创建信息：李晋 8/11/23 10:16
// * 变更履历：
// ***********************************************************************/
//public class ReadWord {
//    /**
//     * 读取docx
//     *
//     * @param filePath 文件路径
//     */
//    public static void readDocx(String filePath) {
//        File file = new File(filePath);
//        try {
//            FileInputStream fis = new FileInputStream(file);
//            XWPFDocument xdoc = new XWPFDocument(fis);
//            XWPFWordExtractor extractor = new XWPFWordExtractor(xdoc);
//            System.out.println(extractor.getText());
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
//
//    /**
//     * 解析docx为html
//     *
//     * @param filePath 文件路径
//     */
//    public static void readDocx(String filePath, String htmlPath) {
//        File file = new File(filePath);
//        try {
//            // 创建文件流
//            FileInputStream fis = new FileInputStream(file);
//            // 解析docx
//            XWPFDocument xdoc = new XWPFDocument(fis);
//            XWPFWordExtractor extractor = new XWPFWordExtractor(xdoc);
//            // 解析 XHTML配置 (这里设置IURIResolver来设置图片存放的目录)
////            File imageFolderFile = new File(filePath);
////            XHTMLOptions options = XHTMLOptions.create().URIResolver(new FileURIResolver(imageFolderFile));
////            options.setExtractor(new FileImageExtractor(imageFolderFile));
////            options.setIgnoreStylesIfUnused(false);
////            options.setFragment(true);
//            // 解析生成html
//            XHTMLConverter.getInstance().convert(xdoc, new FileOutputStream(new File(htmlPath)), null);
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
//
//    /**
//     * 读取doc
//     *
//     * @param filePath 文件路径
//     */
//    public static String readDoc(String filePath) {
//        File file = new File(filePath);
//        String doc1 = "";
//        try {
//            FileInputStream fis = new FileInputStream(file);
//            HWPFDocument doc = new HWPFDocument(fis);
//            doc1 = doc.getDocumentText();
//            System.out.println(doc1);
//            fis.close();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//        return doc1;
//    }
//
//    /**
//     * 解析doc为html
//     *
//     * @param filePath  文件路径
//     * @param htmlPath  html储存路径
//     * @param imagePath 图片储存路径
//     * @return html dom
//     */
//    public static void readDocToHtml(String filePath, String htmlPath, String imagePath) throws IOException, ParserConfigurationException, TransformerException {
//        File file = new File(filePath);
//        // 创建文件流
//        FileInputStream fis = new FileInputStream(file);
//        HWPFDocument wordDocument = new HWPFDocument(fis);
//        WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter(DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument());
//        //设置图片存放的位置
//        wordToHtmlConverter.setPicturesManager(new PicturesManager() {
//            public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches) {
//                File imgPath = new File(imagePath);
//                if (!imgPath.exists()) {//图片目录不存在则创建
//                    imgPath.mkdirs();
//                }
//                File file = new File(imagePath + suggestedName);
//                try {
//                    OutputStream os = new FileOutputStream(file);
//                    os.write(content);
//                    os.close();
//                } catch (FileNotFoundException e) {
//                    e.printStackTrace();
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//                return imagePath + suggestedName;
//            }
//        });
//        //解析word文档
//        wordToHtmlConverter.processDocument(wordDocument);
//        // 文件输出
//        File htmlFile = new File(htmlPath);
//        OutputStream outStream = new FileOutputStream(htmlFile);
//        //也可以使用字符数组流获取解析的内容
//        //        ByteArrayOutputStream baos = new ByteArrayOutputStream();
//        //        OutputStream outStream = new BufferedOutputStream(baos);
//        DOMSource domSource = new DOMSource(wordToHtmlConverter.getDocument());
//        StreamResult streamResult = new StreamResult(outStream);
//        TransformerFactory factory = TransformerFactory.newInstance();
//        Transformer serializer = factory.newTransformer();
//        serializer.setOutputProperty(OutputKeys.ENCODING, "utf-8");
//        serializer.setOutputProperty(OutputKeys.INDENT, "yes");
//        serializer.setOutputProperty(OutputKeys.METHOD, "html");
//        serializer.transform(domSource, streamResult);
//    }
//
//    /**
//     * 解析docx为html
//     *
//     * @param filePath  文件路径
//     * @param htmlPath  html生成路径
//     * @param imagePath 图片储存路径
//     * @return html dom
//     */
//    public static Document readDocxToHtml(String filePath, String htmlPath, String imagePath) throws IOException {
//        File file = new File(filePath);
//        // 创建文件流
//        FileInputStream fis = new FileInputStream(file);
//        XWPFDocument wordDocument = new XWPFDocument(fis);
//        // 2) 解析 XHTML配置 (这里设置IURIResolver来设置图片存放的目录)
//        File imageFolderFile = new File(imagePath);
//        if (!imageFolderFile.exists()) {//图片目录不存在则创建
//            imageFolderFile.mkdirs();
//        }
//        XHTMLOptions options = XHTMLOptions.create().URIResolver(new FileURIResolver(imageFolderFile));
//        options.setExtractor(new FileImageExtractor(imageFolderFile));
//        options.setIgnoreStylesIfUnused(false);
//        options.setFragment(false);
//        // 3) 将 XWPFDocument转换成XHTML
//        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(htmlPath), "utf-8");
//        XHTMLConverter converter = (XHTMLConverter) XHTMLConverter.getInstance();
//        converter.convert(wordDocument, writer, options);
//        //获取解析后的DOM树
//        org.jsoup.nodes.Document htmlDocument = Jsoup.parse(new File(htmlPath), "utf-8");
//        //也可以使用字符数组流获取解析的内容
////                ByteArrayOutputStream baos = new ByteArrayOutputStream();
////                XHTMLConverter.getInstance().convert(document, baos, options);
////                String content = baos.toString();
////                System.out.println(content);
////                 baos.close();
//        fis.close();
//        writer.close();
//        return htmlDocument;
//    }
//
//    /**
//     * 公司需要做出的改变（图片储存未测试）
//     *
//     * @param filePath  word路径
//     * @param htmlPath  输出路径
//     * @param imagePath word中，图片储存路径
//     * @return
//     */
////    public static void hZChangForDoc(String filePath, String htmlPath, String imagePath) {
////        Document htmlDocument = null;
////        try {
////            // 生成html
////            readDocToHtml(filePath, htmlPath, imagePath);
////            // 读取文件获取dom
////            htmlDocument = Jsoup.parse(new File(htmlPath), "utf-8");
////        } catch (IOException | ParserConfigurationException | TransformerException e) {
////            e.printStackTrace();
////        }
////        // 获取body和head节点
////        Element body = htmlDocument.body();
////        Element head = htmlDocument.head();
////        // 获取body的第一个子节点，即第一个P，然后循环查询他的下一个兄弟节点（一开始尝试过获取全部子节点遍历，但是返回的nodeList发现是无序的，所以用此方法）
////        List<Node> nodeList = new ArrayList<>();
////        Node child = body.getFirstChild();
////        while (child != null) {
////            nodeList.add(child);
////            child = child.getNextSibling();
////        }
////        // 添加栅格系统
////        // 创建顶级div
////        Element firstDiv = htmlDocument.createElement("div");
////        firstDiv.attr("class", "layui-row");
////        // 创建导航栏div
////        Element navDiv = htmlDocument.createElement("div");
////        navDiv.attr("class", "layui-col-md2 floatCtro");
////        // 创建内容div
////        Element contentDiv = htmlDocument.createElement("div");
////        contentDiv.attr("class", "layui-col-md10");
////        // 内容div包裹一层pre标签
////        Element pre = htmlDocument.createElement("pre");
////        pre.attr("class", "layui-code layui-box layui-code-view");
////        pre.attr("style", "margin: 0px");
////        contentDiv.appendChild(pre);
////        // 放入所有的P到内容div
////        for (Node node : nodeList) {
////            pre.appendChild(node);
////        }
////        // 建立div之间的上下级关系
////        firstDiv.appendChild(navDiv);
////        firstDiv.appendChild(contentDiv);
////        // firstDiv放入body中
////        body.appendChild(firstDiv);
////        // 获取所有需要加锚点的元素
////        NodeList nodeAList;
////        Map<String, String> anchorMap = new LinkedHashMap<>();
////        if (isDoc) {
////            // doc：遍历所有a标签，以第一个遇到的a标签的父节点p的class为标准，以后遇到父节点p（以及第一个）的class全都加上锚点
////            nodeAList = htmlDocument.getElementsByTagName("a");
////            String pClass = "";
////            for (int i = 0; i < nodeAList.getLength() - 1; ++i) {
////                Element element = (Element) nodeAList.item(i);
////                // 开始检测
////                Element parent = (Element) element.getParentNode();
////                // 第一次进入循环，需要找到要把class为p几的p标签作为锚点
////                if (i == 0) {
////                    // 向上寻找到p标签为止
////                    while (!parent.getNodeName().equals("p")) {
////                        parent = (Element) parent.getParentNode();
////                    }
////                    // 找到上级，获取该节点的class，存储-
////                    pClass = parent.getAttribute("class");
////                }
////                // 第一次循环，或class为指定值
////                if (i == 0 || (parent.getAttribute("class").equals(pClass))) {
////                    String id = IdGen.uuid();
////                    element.attr("id", id);
////                    String text = element.getTextContent();
////                    // 存储该id用于创建左侧导航栏建立锚点
////                    anchorMap.put(id, text);
////                }
////            }
////        } else {
////            // docx：遍历所有包含类X1的span标签全都加上锚点
////            nodeAList = htmlDocument.getElementsByTagName("span");
////            String number = "";
////            for (int i = 0; i < nodeAList.getLength() - 1; ++i) {
////                Element element = (Element) nodeAList.item(i);
////                if (element.getAttribute("class").indexOf("X1") != -1 && !element.getTextContent().matches("[0-9]+|\\s")) {
////                    String id = IdGen.uuid();
////                    element.attr("id", id);
////                    String text = element.getTextContent();
////                    // 前面加上标题序号
////                    text = anchorMap.size() + 1 + text;
////                    // 存储该id用于创建左侧导航栏建立锚点
////                    anchorMap.put(id, text);
////                }
////            }
////        }
////        // 创建左侧导航栏（根据layui）
////        // 创建ul
////        Element ul = htmlDocument.createElement("ul");
////        ul.attr("class", "layui-nav");
////        ul.attr("lay-filter", "test");
////        // 创建li
////        Iterator<Map.Entry<String, String>> iterator = anchorMap.entrySet().iterator();
////        while (iterator.hasNext()) {
////            Map.Entry map = iterator.next();
////            Element li = htmlDocument.createElement("li");
////            li.attr("class", "layui-nav-item");
////            // 创建li中的a标签
////            Element a = htmlDocument.createElement("a");
////            a.attr("href", "#" + map.getKey());
////            a.setTextContent(String.valueOf(map.getValue()));
////            // 建立上下级关系
////            li.appendChild(a);
////            ul.appendChild(li);
////        }
////        // ul放入navDiv中
////        navDiv.appendChild(ul);
////        // 在head节点添加需要引入的css插件
////        Element link = htmlDocument.createElement("link");
////        link.attr("rel", "stylesheet");
////        link.attr("href", "../layui/css/layui.css");
////        head.appendChild(link);
////        // 在body节点中添加js文件
////        Element script = htmlDocument.createElement("script");
////        script.attr("src", "../layui/layui.js");
////        Element script2 = htmlDocument.createElement("script");
////        script2.attr("src", " https://code.jquery.com/jquery-3.3.1.min.js");
////        Element script3 = htmlDocument.createElement("script");
////        script3.setTextContent("$(function(){\n" +
////                "        $('a').click(function(){ //根据a标签的href转换为id选择器，获取id元素所处的位置，并高度减50px（这里根据需要自由设置）\n" +
////                "            $('html,body').animate({scrollTop: ($($(this).attr('href')).offset().top -50 )},1000);\n" +
////                "        });\n" +
////                "    });");
////        body.appendChild(script);
////        body.appendChild(htmlDocument.createElement("br")); // 暂时没有想到其他的方法换行
////        body.appendChild(script2);
////        body.appendChild(htmlDocument.createElement("br"));
////        body.appendChild(script3);
////        body.appendChild(htmlDocument.createElement("br"));
////        // 输出
////        try {
////            outPut(htmlDocument, htmlPath);
////        } catch (FileNotFoundException e) {
////            e.printStackTrace();
////        } catch (TransformerException e) {
////            e.printStackTrace();
////        }
////    }
//
//    /**
//     * 公司需要做出的改变（对于docx）
//     *
//     * @param filePath  word路径
//     * @param htmlPath  输出路径
//     * @param imagePath word中，图片储存路径
//     * @return
//     */
//    public static void hZChangForDocx(String filePath, String htmlPath, String imagePath) {
//        // 读取文件获取dom
//        Document htmlDocument = null;
//        // doc和docx解析方法不同
//        try {
//            htmlDocument = readDocxToHtml(filePath, htmlPath, imagePath);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//        // 获取body和head节点
//        Element body = htmlDocument.body();
//        body.attr("style", "white-space-collapsing:preserve;margin: 1.0in 1.25in 1.0in 1.25in;");
//        Element head = htmlDocument.head();
//        // 获取原body下所有元素
//        Elements oldElements = body.children();
//        // 添加栅格系统
//        // 创建顶级div
//        Element firstDiv = htmlDocument.createElement("div");
//        firstDiv.attr("class", "layui-row");
//        // 创建导航栏div
//        Element navDiv = htmlDocument.createElement("div");
//        navDiv.attr("class", "layui-col-md2 floatCtro");
//        // 创建内容div
//        Element contentDiv = htmlDocument.createElement("div");
//        contentDiv.attr("class", "layui-col-md10");
//        // 内容div包裹一层pre标签
//        Element pre = htmlDocument.createElement("pre");
//        pre.attr("class", "layui-code layui-box layui-code-view");
//        pre.attr("style", "margin: 0px");
//        // 建立所有上下级关系
//        body.appendChild(firstDiv);
//        firstDiv.appendChild(navDiv);
//        firstDiv.appendChild(contentDiv);
//        contentDiv.appendChild(pre);
//        for (Element element : oldElements) {
//            pre.appendChild(element);
//        }
//        // 删除所有<p><br></p>
//        htmlDocument.select("p:has(br)").remove();
//        // 获取所有需要加锚点的元素，即span元素中，只含数字的
//        // 1.元素类中含有a和X1，对应的文件有xqsms(GB856T-88)docx
//        // 2.根据原有目录制作
//        Elements elements = htmlDocument.select(".a .X1");
//        Map<String, String> anchorMap = new LinkedHashMap<>();
//        // 判断文件为第几种情况
//        if (elements == null || elements.size() <= 0) {
//            // 暂时不是第一种情况，则默认第二种情况
//            elements = htmlDocument.select("a[href]");
//            for (int i = 0; i < elements.size(); ++i) {
//                Element element = elements.get(i);
//                String id = IdGen.uuid();
//                element.attr("id", id);
//                // 编辑左右标题导航栏文本
//                String text = element.child(0).text();
//                // 如果该元素内容为空，跳过
//                if (text == null || StringUtils.isBlank(text)) {
//                    continue;
//                }
//                // 如果该元素内容为纯数字或者一个字，则说明内容为<span><a>1</a></span><span><a>1</a></span>形式
//                i = i + 4;
////                anchorMap.put(id);
//            }
//        } else {
//            for (int i = 0; i < elements.size(); ++i) {
//                Element element = elements.get(i);
//                String id = IdGen.uuid();
//                element.attr("id", id);
//                // 编辑左右标题导航栏文本
//                String text = element.text();
//                // 如果该元素内容为空，跳过
//                if (text == null || StringUtils.isBlank(text)) {
//                    continue;
//                }
//                // 如果该元素内容为纯数字或者一个字，则说明内容为<span>1</span><span>标题</span>形式
//                if (text.length() == 1 || text.matches("\\d")) {
//                    if (element.nextElementSibling().text() == null) {
//
//                    }
//                    text += element.nextElementSibling().text();
//                    // 为该形式，则说明下个元素和本元素是同一标题，所以跳过一个
//                    ++i;
//                }
//                anchorMap.put(id, text);
//            }
//        }
//        // 创建左侧导航栏（根据layui）
//        // 创建ul
//        Element ul = htmlDocument.createElement("ul");
//        ul.attr("class", "layui-nav");
//        ul.attr("lay-filter", "test");
//        // 创建li
//        Iterator<Map.Entry<String, String>> iterator = anchorMap.entrySet().iterator();
//        while (iterator.hasNext()) {
//            Map.Entry map = iterator.next();
//            Element li = htmlDocument.createElement("li");
//            li.attr("class", "layui-nav-item");
//            // 创建li中的a标签
//            Element a = htmlDocument.createElement("a");
//            a.attr("href", "#" + map.getKey());
//            a.text(String.valueOf(map.getValue()));
//            // 建立上下级关系
//            li.appendChild(a);
//            ul.appendChild(li);
//        }
//        // ul放入navDiv中
//        navDiv.appendChild(ul);
//        // 在head节点添加需要引入的css插件
//        Element link = htmlDocument.createElement("link");
//        link.attr("rel", "stylesheet");
//        link.attr("href", "../layui/css/layui.css");
//        head.appendChild(link);
//        // 在body节点中添加js文件
//        Element script = htmlDocument.createElement("script");
//        script.attr("src", "../layui/layui.js");
//        Element script2 = htmlDocument.createElement("script");
//        script2.attr("src", " https://code.jquery.com/jquery-3.3.1.min.js");
//        Element script3 = htmlDocument.createElement("script");
//        script3.html("$(function(){\n" +
//                "        $('a').click(function(){ " +
//                "            $('html,body').animate({scrollTop: ($($(this).attr('href')).offset().top -50 )},1000);\n" +
//                "        });\n" +
//                "    });");
//        body.appendChild(script);
//        body.appendChild(htmlDocument.createElement("br")); // 暂时没有想到其他的方法换行
//        body.appendChild(script2);
//        body.appendChild(htmlDocument.createElement("br"));
//        body.appendChild(script3);
//        body.appendChild(htmlDocument.createElement("br"));
//        // 输出
//        try {
//            FileOutputStream fos = new FileOutputStream(htmlPath);
//            OutputStreamWriter osw = new OutputStreamWriter(fos, "utf-8");
//            osw.write(htmlDocument.html());
//            osw.close();
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//}
