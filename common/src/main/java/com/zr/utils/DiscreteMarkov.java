//package com.zr.utils;
//
//import readdoc.util.List;
//
///***********************************************************************
// * 文件说明：离散型马尔可夫链预测模型
// * 创建信息：李晋 2018-11-02 16:36
// * 变更履历：
// ***********************************************************************/
///// <summary>离散型马尔可夫链预测模型</summary>
//public class DiscreteMarkov {
//  //  样本点状态时间序列,按照时间升序
//  public List<Integer> StateList;
//  //  状态总数,对应模型的m
//  public int Count;
//  //  概率转移矩阵Pij
//  public List<DenseMatrix> ProbMatrix;
//  //  各阶的自相关系数
//  public double[] Rk;
//  //  各阶的权重
//  public double[] Wk;
//  //  频数矩阵
//  public int[][] CountStatic;
//  //  目标序列是否满足"马氏性"
//  public Boolean IsMarkov;
//  //  滞时期，K
//  public int LagPeriod;
//  //  预测概率
//  public double[] PredictValue;
//  public DiscreteMarkov(List<Integer> data, int count)  {
//    int k = 5;
//    this.StateList = data;
//    this.LagPeriod = k;
//    this.Count = count;
//    this.CountStatic = StaticCount(data, count);
//    this.ProbMatrix = new List<DenseMatrix>();
//    // 计算转移概率（双色球规则，由购买者从01-33共33个红色号码球中选择6个号码，并从01-16共16个蓝色号码球中选择1个号码，组合为一注投注号码的基本投注。）
//    for (int i = 1; i < K; i++) //根据CK方程，计算各步的状态转移矩阵
//    {
//      var temp = ProbMatrix[i - 1] * t0;
//      ProbMatrix.Add(temp);
//    }
//    if (ValidateMarkov()) {
//      CorrCoefficient();
//      TimeWeight();
//      PredictProb();
//    } else {
//      System.out.println("马氏性 检验失败,无法进行下一步预测");
//    }
//  }
//  //  验证是否满足马氏性,默认的显著性水平是0.05，自由度25
//  public Boolean ValidateMarkov() {
//    //计算列和
//    int[] cp1 = new int[Count];
//    int allcount = CountStatic.Select(n = > n.Sum()).Sum();//总数
//
//    for (int i = 0; i < Count; i++) {
//      for (int j = 0; j < Count; j++) {
//        cp1[i] += CountStatic[j][i];
//      }
//    }
//    double[] cp = cp1.Select(n = > (double) n / (double) allcount).ToArray();
//
//    //计算伽马平方统计量
//    double gm = 0;
//    for (int i = 0; i < Count; i++) {
//      for (int j = 0; j < Count; j++) {
//        if (CountStatic[i][j] != 0) {
//          gm += 2 * CountStatic[i][j] * Math.Abs(Math.Log(ProbMatrix[0][i, j
//        }] /cp[j], Math.E));
//      }
//    }
//    //查表求a = 0.05时，伽马分布的临界值F(m-1)^2,如果实际的gm值大于差别求得的值，则满足
//    //查表要自己做表，这里只演示0.05的情况  卡方分布
//    return gm >= 37.65;
//  }
//
//  //  计算相关系数
//  public void CorrCoefficient() {
//    double mean = (double) StateList.Sum() / (double) StateList.Count;//均值
//
//    double p = StateList.Select(n = > (n - mean) * (n - mean)).Sum();
//
//    Rk = new double[LagPeriod];
//
//    for (int i = 0; i < LagPeriod; i++) {
//      double s1 = 0;
//      for (int L = 0; L < StateList.Count - LagPeriod; L++) {
//        s1 += (StateList[L] - mean) * (StateList[L + i] - mean);
//      }
//      Rk[i] = s1 / p;
//    }
//  }
//
//  /// <summary>计算滞时的步长</summary>
//  public void TimeWeight() {
//    double sum = Rk.Select(n = > Math.Abs(n)).Sum();
//    Wk = Rk.Select(n = > Math.Abs(n) / sum).ToArray();
//  }
//
//  /// <summary>预测状态概率</summary>
//  public void PredictProb() {
//    PredictValue = new double[Count];
//    //这里很关键，权重和滞时的关系要颠倒，循环计算的时候要注意
//    //另外，要根据最近几期的出现数，确定概率的状态，必须取出最后几期的数据
//
//    //1.先取最后K期数据
//    var last = StateList.GetRange(StateList.size() - LagPeriod, LagPeriod);
//    //2.注意last数据是升序,最后一位对于的滞时期 是k =1
//    for (int i = 0; i < Count; i++) {
//      for (int j = 0; j < LagPeriod; j++) {
//        //滞时期j的数据状态
//        var state = last[last.Count - 1 - j] - 1;
//        PredictValue[i] += Wk[j] * ProbMatrix[j][state, i];
//      }
//    }
//  }
//
//  //  统计频数矩阵
//  public static int[][] StaticCount(List<Integer> data, int statusCount) {
//    int[][] res = new int[statusCount][];
//    for (int i = 0; i < statusCount; i++) {
//      res[i] = new int[statusCount];
//    }
//    for (int i = 0; i < data.size() - 1; i++) {
//      res[data.get(i) - 1][data.get(i + 1) - 1]++;
//    }
//    return res;
//  }
//
//  /// 根据频数，计算转移概率矩阵
//  //  频率矩阵
//  public static double[][] StaticProbability(int[][] data) {
//    double[][] res = new double[data.length][];
//    for (int i = 0; i < data.length; i++) {
//      int sum = data[i].Sum();
//      res[i] = data[i].Select(n = > (double) n / (double) sum).ToArray();
//    }
//    return res;
//  }
//}